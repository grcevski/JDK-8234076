<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/java.base/share/native/libjli/args.c</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;stdlib.h&gt;
  27 #include &lt;stdio.h&gt;
  28 #include &lt;assert.h&gt;
  29 #include &lt;sys/stat.h&gt;
  30 #include &lt;ctype.h&gt;
  31 
  32 #ifdef DEBUG_ARGFILE
  33   #ifndef NO_JNI
  34     #define NO_JNI
  35   #endif
  36   #define JLI_ReportMessage(...) printf(__VA_ARGS__)
  37   #define JDK_JAVA_OPTIONS "JDK_JAVA_OPTIONS"
  38   int IsWhiteSpaceOption(const char* name) { return 1; }
  39 #else
  40   #include "java.h"
  41   #include "jni.h"
  42 #endif
  43 
  44 #include "jli_util.h"
  45 #include "emessages.h"
  46 
  47 #define MAX_ARGF_SIZE 0x7fffffffL
  48 
  49 static char* clone_substring(const char *begin, size_t len) {
  50     char *rv = (char *) JLI_MemAlloc(len + 1);
  51     memcpy(rv, begin, len);
  52     rv[len] = '\0';
  53     return rv;
  54 }
  55 
  56 enum STATE {
  57     FIND_NEXT,
  58     IN_COMMENT,
  59     IN_QUOTE,
  60     IN_ESCAPE,
  61     SKIP_LEAD_WS,
  62     IN_TOKEN
  63 };
  64 
  65 typedef struct {
  66     enum STATE state;
  67     const char* cptr;
  68     const char* eob;
  69     char quote_char;
  70     JLI_List parts;
  71 } __ctx_args;
  72 
  73 #define NOT_FOUND -1
  74 static int firstAppArgIndex = NOT_FOUND;
  75 
  76 static jboolean expectingNoDashArg = JNI_FALSE;
  77 // Initialize to 1, as the first argument is the app name and not preprocessed
  78 static size_t argsCount = 1;
  79 static jboolean stopExpansion = JNI_FALSE;
  80 static jboolean relaunch = JNI_FALSE;
  81 
  82 /*
  83  * Prototypes for internal functions.
  84  */
  85 static jboolean expand(JLI_List args, const char *str, const char *var_name);
  86 
  87 JNIEXPORT void JNICALL
  88 JLI_InitArgProcessing(jboolean hasJavaArgs, jboolean disableArgFile) {
  89     // No expansion for relaunch
  90     if (argsCount != 1) {
  91         relaunch = JNI_TRUE;
  92         stopExpansion = JNI_TRUE;
  93         argsCount = 1;
  94     } else {
  95         stopExpansion = disableArgFile;
  96     }
  97 
  98     expectingNoDashArg = JNI_FALSE;
  99 
 100     // for tools, this value remains 0 all the time.
 101     firstAppArgIndex = hasJavaArgs ? 0: NOT_FOUND;
 102 }
 103 
 104 JNIEXPORT int JNICALL
 105 JLI_GetAppArgIndex() {
 106     // Will be 0 for tools
 107     return firstAppArgIndex;
 108 }
 109 
 110 static void checkArg(const char *arg) {
 111     size_t idx = 0;
 112     argsCount++;
 113 
 114     // All arguments arrive here must be a launcher argument,
 115     // ie. by now, all argfile expansions must have been performed.
 116     if (*arg == '-') {
 117         expectingNoDashArg = JNI_FALSE;
 118         if (IsWhiteSpaceOption(arg)) {
 119             // expect an argument
 120             expectingNoDashArg = JNI_TRUE;
 121 
 122             if (JLI_StrCmp(arg, "-jar") == 0 ||
 123                 JLI_StrCmp(arg, "--module") == 0 ||
 124                 JLI_StrCmp(arg, "-m") == 0) {
 125                 // This is tricky, we do expect NoDashArg
 126                 // But that is considered main class to stop expansion
 127                 expectingNoDashArg = JNI_FALSE;
 128                 // We can not just update the idx here because if -jar @file
 129                 // still need expansion of @file to get the argument for -jar
 130             }
 131         } else if (JLI_StrCmp(arg, "--disable-@files") == 0) {
 132             stopExpansion = JNI_TRUE;
 133         } else if (JLI_StrCCmp(arg, "--module=") == 0) {
 134             idx = argsCount;
 135         }
 136     } else {
 137         if (!expectingNoDashArg) {
 138             // this is main class, argsCount is index to next arg
 139             idx = argsCount;
 140         }
 141         expectingNoDashArg = JNI_FALSE;
 142     }
 143     // only update on java mode and not yet found main class
 144     if (firstAppArgIndex == NOT_FOUND &amp;&amp; idx != 0) {
 145         firstAppArgIndex = (int) idx;
 146     }
 147 }
 148 
 149 /*
 150        [\n\r]   +------------+                        +------------+ [\n\r]
 151       +---------+ IN_COMMENT +&lt;------+                | IN_ESCAPE  +---------+
 152       |         +------------+       |                +------------+         |
 153       |    [#]       ^               |[#]                 ^     |            |
 154       |   +----------+               |                [\\]|     |[^\n\r]     |
 155       v   |                          |                    |     v            |
 156 +------------+ [^ \t\n\r\f]  +------------+['"]&gt;      +------------+         |
 157 | FIND_NEXT  +--------------&gt;+ IN_TOKEN   +-----------+ IN_QUOTE   +         |
 158 +------------+               +------------+   &lt;[quote]+------------+         |
 159   |   ^                          |                       |  ^   ^            |
 160   |   |               [ \t\n\r\f]|                 [\n\r]|  |   |[^ \t\n\r\f]v
 161   |   +--------------------------+-----------------------+  |  +--------------+
 162   |                       ['"]                              |  | SKIP_LEAD_WS |
 163   +---------------------------------------------------------+  +--------------+
 164 */
 165 static char* nextToken(__ctx_args *pctx) {
 166     const char* nextc = pctx-&gt;cptr;
 167     const char* const eob = pctx-&gt;eob;
 168     const char* anchor = nextc;
 169     char *token;
 170 
 171     for (; nextc &lt; eob; nextc++) {
 172         register char ch = *nextc;
 173 
 174         // Skip white space characters
 175         if (pctx-&gt;state == FIND_NEXT || pctx-&gt;state == SKIP_LEAD_WS) {
 176             while (ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t' || ch == '\f') {
 177                 nextc++;
 178                 if (nextc &gt;= eob) {
 179                     return NULL;
 180                 }
 181                 ch = *nextc;
 182             }
 183             pctx-&gt;state = (pctx-&gt;state == FIND_NEXT) ? IN_TOKEN : IN_QUOTE;
 184             anchor = nextc;
 185         // Deal with escape sequences
 186         } else if (pctx-&gt;state == IN_ESCAPE) {
 187             // concatenation directive
 188             if (ch == '\n' || ch == '\r') {
 189                 pctx-&gt;state = SKIP_LEAD_WS;
 190             } else {
 191             // escaped character
 192                 char* escaped = (char*) JLI_MemAlloc(2 * sizeof(char));
 193                 escaped[1] = '\0';
 194                 switch (ch) {
 195                     case 'n':
 196                         escaped[0] = '\n';
 197                         break;
 198                     case 'r':
 199                         escaped[0] = '\r';
 200                         break;
 201                     case 't':
 202                         escaped[0] = '\t';
 203                         break;
 204                     case 'f':
 205                         escaped[0] = '\f';
 206                         break;
 207                     default:
 208                         escaped[0] = ch;
 209                         break;
 210                 }
 211                 JLI_List_add(pctx-&gt;parts, escaped);
 212                 pctx-&gt;state = IN_QUOTE;
 213             }
 214             // anchor to next character
 215             anchor = nextc + 1;
 216             continue;
 217         // ignore comment to EOL
 218         } else if (pctx-&gt;state == IN_COMMENT) {
 219             while (ch != '\n' &amp;&amp; ch != '\r') {
 220                 nextc++;
 221                 if (nextc &gt; eob) {
 222                     return NULL;
 223                 }
 224                 ch = *nextc;
 225             }
 226             pctx-&gt;state = FIND_NEXT;
 227             continue;
 228         }
 229 
 230         assert(pctx-&gt;state != IN_ESCAPE);
 231         assert(pctx-&gt;state != FIND_NEXT);
 232         assert(pctx-&gt;state != SKIP_LEAD_WS);
 233         assert(pctx-&gt;state != IN_COMMENT);
 234 
 235         switch(ch) {
 236             case ' ':
 237             case '\t':
 238             case '\f':
 239                 if (pctx-&gt;state == IN_QUOTE) {
 240                     continue;
 241                 }
 242                 // fall through
 243             case '\n':
 244             case '\r':
 245                 if (pctx-&gt;parts-&gt;size == 0) {
 246                     token = clone_substring(anchor, nextc - anchor);
 247                 } else {
 248                     JLI_List_addSubstring(pctx-&gt;parts, anchor, nextc - anchor);
 249                     token = JLI_List_combine(pctx-&gt;parts);
 250                     JLI_List_free(pctx-&gt;parts);
 251                     pctx-&gt;parts = JLI_List_new(4);
 252                 }
 253                 pctx-&gt;cptr = nextc + 1;
 254                 pctx-&gt;state = FIND_NEXT;
 255                 return token;
 256             case '#':
 257                 if (pctx-&gt;state == IN_QUOTE) {
 258                     continue;
 259                 }
 260                 pctx-&gt;state = IN_COMMENT;
 261                 break;
 262             case '\\':
 263                 if (pctx-&gt;state != IN_QUOTE) {
 264                     continue;
 265                 }
 266                 JLI_List_addSubstring(pctx-&gt;parts, anchor, nextc - anchor);
 267                 pctx-&gt;state = IN_ESCAPE;
 268                 // anchor after backslash character
 269                 anchor = nextc + 1;
 270                 break;
 271             case '\'':
 272             case '"':
 273                 if (pctx-&gt;state == IN_QUOTE &amp;&amp; pctx-&gt;quote_char != ch) {
 274                     // not matching quote
 275                     continue;
 276                 }
 277                 // partial before quote
 278                 if (anchor != nextc) {
 279                     JLI_List_addSubstring(pctx-&gt;parts, anchor, nextc - anchor);
 280                 }
 281                 // anchor after quote character
 282                 anchor = nextc + 1;
 283                 if (pctx-&gt;state == IN_TOKEN) {
 284                     pctx-&gt;quote_char = ch;
 285                     pctx-&gt;state = IN_QUOTE;
 286                 } else {
 287                     pctx-&gt;state = IN_TOKEN;
 288                 }
 289                 break;
 290             default:
 291                 break;
 292         }
 293     }
 294 
 295     assert(nextc == eob);
 296     if (anchor != nextc) {
 297         // not yet return until end of stream, we have part of a token.
 298         JLI_List_addSubstring(pctx-&gt;parts, anchor, nextc - anchor);
 299     }
 300     return NULL;
 301 }
 302 
 303 static JLI_List readArgFile(FILE *file) {
 304     char buf[4096];
 305     JLI_List rv;
 306     __ctx_args ctx;
 307     size_t size;
 308     char *token;
 309 
 310     ctx.state = FIND_NEXT;
 311     ctx.parts = JLI_List_new(4);
 312     // initialize to avoid -Werror=maybe-uninitialized issues from gcc 7.3 onwards.
 313     ctx.quote_char = '"';
 314 
 315     /* arbitrarily pick 8, seems to be a reasonable number of arguments */
 316     rv = JLI_List_new(8);
 317 
 318     while (!feof(file)) {
 319         size = fread(buf, sizeof(char), sizeof(buf), file);
 320         if (ferror(file)) {
 321             JLI_List_free(rv);
 322             return NULL;
 323         }
 324 
 325         /* nextc is next character to read from the buffer
 326          * eob is the end of input
 327          * token is the copied token value, NULL if no a complete token
 328          */
 329         ctx.cptr = buf;
 330         ctx.eob = buf + size;
 331         token = nextToken(&amp;ctx);
 332         while (token != NULL) {
 333             checkArg(token);
 334             JLI_List_add(rv, token);
 335             token = nextToken(&amp;ctx);
 336         }
 337     }
 338 
 339     // remaining partial token
 340     if (ctx.state == IN_TOKEN || ctx.state == IN_QUOTE) {
 341         if (ctx.parts-&gt;size != 0) {
 342             token = JLI_List_combine(ctx.parts);
 343             checkArg(token);
 344             JLI_List_add(rv, token);
 345         }
 346     }
 347     JLI_List_free(ctx.parts);
 348 
 349     return rv;
 350 }
 351 
 352 /*
 353  * if the arg represent a file, that is, prefix with a single '@',
 354  * return a list of arguments from the file.
 355  * otherwise, return NULL.
 356  */
 357 static JLI_List expandArgFile(const char *arg) {
 358     FILE *fptr;
 359     struct stat st;
 360     JLI_List rv;
 361 
 362     /* failed to access the file */
 363     if (stat(arg, &amp;st) != 0) {
 364         JLI_ReportMessage(CFG_ERROR6, arg);
 365         exit(1);
 366     }
 367 
 368     if (st.st_size &gt; MAX_ARGF_SIZE) {
 369         JLI_ReportMessage(CFG_ERROR10, MAX_ARGF_SIZE);
 370         exit(1);
 371     }
 372 
 373     fptr = fopen(arg, "r");
 374     /* arg file cannot be openned */
 375     if (fptr == NULL) {
 376         JLI_ReportMessage(CFG_ERROR6, arg);
 377         exit(1);
 378     }
 379 
 380     rv = readArgFile(fptr);
 381     fclose(fptr);
 382 
 383     /* error occurred reading the file */
 384     if (rv == NULL) {
 385         JLI_ReportMessage(DLL_ERROR4, arg);
 386         exit(1);
 387     }
 388 
 389     return rv;
 390 }
 391 
 392 /*
 393  * expand a string into a list of words separated by whitespace.
 394  */
 395 static JLI_List expandArg(const char *arg) {
 396     JLI_List rv;
 397 
 398     /* arbitrarily pick 8, seems to be a reasonable number of arguments */
 399     rv = JLI_List_new(8);
 400 
 401     expand(rv, arg, NULL);
 402 
 403     return rv;
 404 }
 405 
 406 JNIEXPORT JLI_List JNICALL
 407 JLI_PreprocessArg(const char *arg, jboolean expandSourceOpt) {
 408     JLI_List rv;
 409 
 410     if (firstAppArgIndex &gt; 0) {
 411         // In user application arg, no more work.
 412         return NULL;
 413     }
 414 
 415     if (stopExpansion) {
 416         // still looking for user application arg
 417         checkArg(arg);
 418         return NULL;
 419     }
 420 
 421     if (expandSourceOpt
 422             &amp;&amp; JLI_StrCCmp(arg, "--source") == 0
 423             &amp;&amp; JLI_StrChr(arg, ' ') != NULL) {
 424         return expandArg(arg);
 425     }
 426 
 427     if (arg[0] != '@') {
 428         checkArg(arg);
 429         return NULL;
 430     }
 431 
 432     if (arg[1] == '\0') {
 433         // @ by itself is an argument
 434         checkArg(arg);
 435         return NULL;
 436     }
 437 
 438     arg++;
 439     if (arg[0] == '@') {
 440         // escaped @argument
 441         rv = JLI_List_new(1);
 442         checkArg(arg);
 443         JLI_List_add(rv, JLI_StringDup(arg));
 444     } else {
 445         rv = expandArgFile(arg);
 446     }
 447     return rv;
 448 }
 449 
 450 int isTerminalOpt(char *arg) {
 451     return JLI_StrCmp(arg, "-jar") == 0 ||
 452            JLI_StrCmp(arg, "-m") == 0 ||
 453            JLI_StrCmp(arg, "--module") == 0 ||
 454            JLI_StrCmp(arg, "--dry-run") == 0 ||
 455            JLI_StrCmp(arg, "-h") == 0 ||
 456            JLI_StrCmp(arg, "-?") == 0 ||
 457            JLI_StrCmp(arg, "-help") == 0 ||
 458            JLI_StrCmp(arg, "--help") == 0 ||
 459            JLI_StrCmp(arg, "-X") == 0 ||
 460            JLI_StrCmp(arg, "--help-extra") == 0 ||
 461            JLI_StrCmp(arg, "-version") == 0 ||
 462            JLI_StrCmp(arg, "--version") == 0 ||
 463            JLI_StrCmp(arg, "-fullversion") == 0 ||
 464            JLI_StrCmp(arg, "--full-version") == 0;
 465 }
 466 
 467 JNIEXPORT jboolean JNICALL
 468 JLI_AddArgsFromEnvVar(JLI_List args, const char *var_name) {
 469     char *env = getenv(var_name);
 470 
 471     if (firstAppArgIndex == 0) {
 472         // Not 'java', return
 473         return JNI_FALSE;
 474     }
 475 
 476     if (relaunch) {
 477         return JNI_FALSE;
 478     }
 479 
 480     if (NULL == env) {
 481         return JNI_FALSE;
 482     }
 483 
 484     JLI_ReportMessage(ARG_INFO_ENVVAR, var_name, env);
 485     return expand(args, env, var_name);
 486 }
 487 
 488 /*
 489  * Expand a string into a list of args.
 490  * If the string is the result of looking up an environment variable,
 491  * var_name should be set to the name of that environment variable,
 492  * for use if needed in error messages.
 493  */
 494 
 495 static jboolean expand(JLI_List args, const char *str, const char *var_name) {
 496     jboolean inEnvVar = (var_name != NULL);
 497 
 498     char *p, *arg;
 499     char quote;
 500     JLI_List argsInFile;
 501 
 502     // This is retained until the process terminates as it is saved as the args
 503     p = JLI_MemAlloc(JLI_StrLen(str) + 1);
 504     while (*str != '\0') {
 505         while (*str != '\0' &amp;&amp; isspace(*str)) {
 506             str++;
 507         }
 508 
 509         // Trailing space
 510         if (*str == '\0') {
 511             break;
 512         }
 513 
 514         arg = p;
 515         while (*str != '\0' &amp;&amp; !isspace(*str)) {
 516             if (inEnvVar &amp;&amp; (*str == '"' || *str == '\'')) {
 517                 quote = *str++;
 518                 while (*str != quote &amp;&amp; *str != '\0') {
 519                     *p++ = *str++;
 520                 }
 521 
 522                 if (*str == '\0') {
 523                     JLI_ReportMessage(ARG_ERROR8, var_name);
 524                     exit(1);
 525                 }
 526                 str++;
 527             } else {
 528                 *p++ = *str++;
 529             }
 530         }
 531 
 532         *p++ = '\0';
 533 
 534         argsInFile = JLI_PreprocessArg(arg, JNI_FALSE);
 535 
 536         if (NULL == argsInFile) {
 537             if (isTerminalOpt(arg)) {
 538                 if (inEnvVar) {
 539                     JLI_ReportMessage(ARG_ERROR9, arg, var_name);
 540                 } else {
 541                     JLI_ReportMessage(ARG_ERROR15, arg);
 542                 }
 543                 exit(1);
 544             }
 545             JLI_List_add(args, arg);
 546         } else {
 547             size_t cnt, idx;
 548             char *argFile = arg;
 549             cnt = argsInFile-&gt;size;
 550             for (idx = 0; idx &lt; cnt; idx++) {
 551                 arg = argsInFile-&gt;elements[idx];
 552                 if (isTerminalOpt(arg)) {
 553                     if (inEnvVar) {
 554                         JLI_ReportMessage(ARG_ERROR10, arg, argFile, var_name);
 555                     } else {
 556                         JLI_ReportMessage(ARG_ERROR16, arg, argFile);
 557                     }
 558                     exit(1);
 559                 }
 560                 JLI_List_add(args, arg);
 561             }
 562             // Shallow free, we reuse the string to avoid copy
 563             JLI_MemFree(argsInFile-&gt;elements);
 564             JLI_MemFree(argsInFile);
 565         }
 566         /*
 567          * Check if main-class is specified after argument being checked. It
 568          * must always appear after expansion, as a main-class could be specified
 569          * indirectly into environment variable via an @argfile, and it must be
 570          * caught now.
 571          */
 572         if (firstAppArgIndex != NOT_FOUND) {
 573             if (inEnvVar) {
 574                 JLI_ReportMessage(ARG_ERROR11, var_name);
 575             } else {
 576                 JLI_ReportMessage(ARG_ERROR17);
 577             }
 578             exit(1);
 579         }
 580 
 581         assert (*str == '\0' || isspace(*str));
 582     }
 583 
 584     return JNI_TRUE;
 585 }
 586 
 587 #ifdef DEBUG_ARGFILE
 588 /*
 589  * Stand-alone sanity test, build with following command line
 590  * $ CC -DDEBUG_ARGFILE -DNO_JNI -g args.c jli_util.c
 591  */
 592 
 593 void fail(char *expected, char *actual, size_t idx) {
 594     printf("FAILED: Token[%lu] expected to be &lt;%s&gt;, got &lt;%s&gt;\n", idx, expected, actual);
 595     exit(1);
 596 }
 597 
 598 void test_case(char *case_data, char **tokens, size_t cnt_tokens) {
 599     size_t actual_cnt;
 600     char *token;
 601     __ctx_args ctx;
 602 
 603     actual_cnt = 0;
 604 
 605     ctx.state = FIND_NEXT;
 606     ctx.parts = JLI_List_new(4);
 607     ctx.cptr = case_data;
 608     ctx.eob = case_data + strlen(case_data);
 609 
 610     printf("Test case: &lt;%s&gt;, expected %lu tokens.\n", case_data, cnt_tokens);
 611 
 612     for (token = nextToken(&amp;ctx); token != NULL; token = nextToken(&amp;ctx)) {
 613         // should not have more tokens than expected
 614         if (actual_cnt &gt;= cnt_tokens) {
 615             printf("FAILED: Extra token detected: &lt;%s&gt;\n", token);
 616             exit(2);
 617         }
 618         if (JLI_StrCmp(token, tokens[actual_cnt]) != 0) {
 619             fail(tokens[actual_cnt], token, actual_cnt);
 620         }
 621         actual_cnt++;
 622     }
 623 
 624     char* last = NULL;
 625     if (ctx.parts-&gt;size != 0) {
 626         last = JLI_List_combine(ctx.parts);
 627     }
 628     JLI_List_free(ctx.parts);
 629 
 630     if (actual_cnt &gt;= cnt_tokens) {
 631         // same number of tokens, should have nothing left to parse
 632         if (last != NULL) {
 633             if (*last != '#') {
 634                 printf("Leftover detected: %s", last);
 635                 exit(2);
 636             }
 637         }
 638     } else {
 639         if (JLI_StrCmp(last, tokens[actual_cnt]) != 0) {
 640             fail(tokens[actual_cnt], last, actual_cnt);
 641         }
 642         actual_cnt++;
 643     }
 644     if (actual_cnt != cnt_tokens) {
 645         printf("FAILED: Number of tokens not match, expected %lu, got %lu\n",
 646             cnt_tokens, actual_cnt);
 647         exit(3);
 648     }
 649 
 650     printf("PASS\n");
 651 }
 652 
 653 #define DO_CASE(name) \
 654     test_case(name[0], name + 1, sizeof(name)/sizeof(char*) - 1)
 655 
 656 int main(int argc, char** argv) {
 657     size_t i, j;
 658 
 659     char* case1[] = { "-version -cp \"c:\\\\java libs\\\\one.jar\" \n",
 660         "-version", "-cp", "c:\\java libs\\one.jar" };
 661     DO_CASE(case1);
 662 
 663     // note the open quote at the end
 664     char* case2[] = { "com.foo.Panda \"Furious 5\"\fand\t'Shi Fu' \"escape\tprison",
 665         "com.foo.Panda", "Furious 5", "and", "Shi Fu", "escape\tprison"};
 666     DO_CASE(case2);
 667 
 668     char* escaped_chars[] = { "escaped chars testing \"\\a\\b\\c\\f\\n\\r\\t\\v\\9\\6\\23\\82\\28\\377\\477\\278\\287\"",
 669         "escaped", "chars", "testing", "abc\f\n\r\tv96238228377477278287"};
 670     DO_CASE(escaped_chars);
 671 
 672     char* mixed_quote[]  = { "\"mix 'single quote' in double\" 'mix \"double quote\" in single' partial\"quote me\"this",
 673         "mix 'single quote' in double", "mix \"double quote\" in single", "partialquote methis"};
 674     DO_CASE(mixed_quote);
 675 
 676     char* comments[]  = { "line one #comment\n'line #2' #rest are comment\r\n#comment on line 3\nline 4 #comment to eof",
 677         "line", "one", "line #2", "line", "4"};
 678     DO_CASE(comments);
 679 
 680     char* open_quote[] = { "This is an \"open quote \n    across line\n\t, note for WS.",
 681         "This", "is", "an", "open quote ", "across", "line", ",", "note", "for", "WS." };
 682     DO_CASE(open_quote);
 683 
 684     char* escape_in_open_quote[] = { "Try \"this \\\\\\\\ escape\\n double quote \\\" in open quote",
 685         "Try", "this \\\\ escape\n double quote \" in open quote" };
 686     DO_CASE(escape_in_open_quote);
 687 
 688     char* quote[] = { "'-Dmy.quote.single'='Property in single quote. Here a double quote\" Add some slashes \\\\/'",
 689         "-Dmy.quote.single=Property in single quote. Here a double quote\" Add some slashes \\/" };
 690     DO_CASE(quote);
 691 
 692     char* multi[] = { "\"Open quote to \n  new \"line \\\n\r   third\\\n\r\\\tand\ffourth\"",
 693         "Open quote to ", "new", "line third\tand\ffourth" };
 694     DO_CASE(multi);
 695 
 696     char* escape_quote[] = { "c:\\\"partial quote\"\\lib",
 697         "c:\\partial quote\\lib" };
 698     DO_CASE(escape_quote);
 699 
 700     if (argc &gt; 1) {
 701         for (i = 0; i &lt; argc; i++) {
 702             JLI_List tokens = JLI_PreprocessArg(argv[i], JNI_FALSE);
 703             if (NULL != tokens) {
 704                 for (j = 0; j &lt; tokens-&gt;size; j++) {
 705                     printf("Token[%lu]: &lt;%s&gt;\n", (unsigned long) j, tokens-&gt;elements[j]);
 706                 }
 707             }
 708         }
 709     }
 710 }
 711 
 712 #endif // DEBUG_ARGFILE
</pre></body></html>
